---
title: DFS算法
date: 2023-3-5
tags: [DFS, 算法]
category: 算法
---

# bfs和dfs的区别

**bfs更适合解决带有“最少”，“最短”字样的题**
**dfs更适合解决带有“刚刚”，“刚好”字样的题**
在练习迷宫问题之前，先介绍一下奇偶性剪枝：

若地图上某点的行号加列号为奇数，则将其定义为奇点；
若地图上某点的行号加列号为偶数，则将其定义为偶点；
行与列从(0，0)开始
奇点用1表示
偶点用0表示
通过以上定义可以把一个地图表示为下图（01相间）：

```
0 1 0 1
1 0 1 0
0 1 0 1
```

不难发现：

在每一步消耗一个单位时间的情况下：

**0的下一步只能走向1**
**1的下一步只能走向0**
**从0走向1需要的步数(时间)一定是奇数**
**从1走向0需要的步数(时间)一定是奇数**
**从0走向0需要的步数(时间)一定是偶数**
**从1走向1需要的步数(时间)一定是偶数**
通过这个性质可以对一些问题进行剪枝，称奇偶性剪枝。

# B. **手机的诱惑**

## 题目描述

Problem Description
张晨乐在一个古老的迷宫中发现了一个手机，这个手机深深地吸引了他。

然而，当他拾起手机，迷宫开始摇晃，张晨乐能感觉到地面下沉。他意识到：这个手机只是一个诱饵！于是，他不顾一切地试图冲出这个迷宫。

迷宫是一个大小为N*M的矩形，有一扇门，一开始，门是关闭的，并在第T秒打开一瞬间（小于1秒的时间）。因此，张晨乐必须刚好在第T秒钟到达门口。
每一秒，他都可以向上，下，左，右四个相邻的位置中的任意一个移动。一旦他进入一个新的地方，这个地方的地面就会开始下沉，并在下一秒消失。因此，他不能在一个地方停留超过一秒钟，也不能再进入曾经走过的地方。

请问，可怜的张晨乐能够逃出迷宫吗？

Input
输入由多个测试用例组成。
每个测试用例的第一行包含三个整数N，M和T（1 <N，M <7; 0 <T <50），分别表示迷宫的大小和门打开的时间。
接下来的N行给出迷宫布局，每行包含M个字符。

每个字符含义如下：

‘X’：不能进入的墙
‘S’：起点
‘D’：门
‘.’：可以行走的地方

输入以三个0结束，这个测试用例不被处理。

Output
对于每组测试数据，如果张晨乐能够逃出迷宫，则请输出“YES”，否则，请输出“NO”。每组数据输出占一行。



## 输入样例

```
4 4 5
S.X.
..X.
..XD
....
3 4 5
S.X.
..X.
...D
0 0 0
 
```

输出样例

```
NO
YES
```

## AC代码

```c++
//DFS 迷宫 必须刚好在t时刻到达终点
#include <bits/stdc++.h>
using namespace std;
char Map[10][10];//Map用来存储迷宫的布局
int dir[4][2]={{0,-1},{0,1},{1,0},{-1,0}};//表示可以移动的四个方位
int n,m,t,di,dj;//迷宫大小为n*m,t秒时门打开,门的位置是(di,dj)
bool escape;
void dfs(int si,int sj,int cnt);//开始位置为(si,sj),当前所花时间为cnt秒

int main()
{
    int i,j,si,sj;
    while(cin>>n>>m>>t)
    {
        if(n==0&&m==0&&t==0)//结束输入
            break;
        int wall=0;//墙的数量
        for(i=1;i<=n;i++)
        {
            for(j=1;j<=m;j++)
            {
                cin>>Map[i][j];
                if(Map[i][j]=='S')
                {
                    si=i;
                    sj=j;
                }
                else if(Map[i][j]=='D')
                {
                    di=i;
                    dj=j;
                }
                else if(Map[i][j]=='X')
                    wall++;
            }
        }       
        if(n*m-wall<=t)//剪枝
        {
            printf("NO\n");
            continue;
        }
        escape=0;
        Map[si][sj]='X';
        dfs(si,sj,0);
        if(escape)
            printf("YES\n");
        else
            printf("NO\n");
    }
    return 0;
}
void dfs(int si,int sj,int cnt)
{
    int i,temp,x,y;
    //判断当前状态有没有逃出去
    if(si>n||sj>m||si<=0||sj<=0)
        return;
    if(cnt==t&&si==di&&sj==dj)
        escape=1;
    if(escape)
        return;
    temp=(t-cnt)-abs(si-di)-abs(sj-dj);//剩余时间-最短时间
    if(temp<0||temp%2==1)//奇偶性剪枝:因为以最短时间到了终点，必须要再花偶数时间，才能做到最后依旧呆在终点
        return;
    
    for(i=0;i<4;i++)
    {
        x=si+dir[i][0];
        y=sj+dir[i][1];
        if(Map[x][y]!='X')
        {
            Map[x][y]='X';
            dfs(x,y,cnt+1);
            Map[x][y]='.';//回溯
        }
    }
    return;
}
```







