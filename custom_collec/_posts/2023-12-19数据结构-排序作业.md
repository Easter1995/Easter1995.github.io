---
title: 数据结构-排序作业
date: 2023-12-19
---



# 选择题

1. C

2. B

   插入排序：有可能最后一趟需要所有元素全部向后移一位

3. A

4. C

   堆排序：O(1)

   归并排序：O(n)

   快速排序：O(logn)

5. C

6. A

7. D

8. B

9. D

10. D

11. B

12. D

13. B

# 简答题

1. 

   1. 直接插入排序

      | 趟数 | 关键码状态                                  |
      | ---- | ------------------------------------------- |
      | 1    | 【503】087 512 061 908 170 897 275 653 426  |
      | 2    | 【087 503】512 061 908 170 897 275 653 426  |
      | 3    | 【087 503 512】061 908 170 897 275 653 426  |
      | 4    | 【061 087 503 512】908 170 897 275 653 426  |
      | 5    | 【061 087 503 512 908】170 897 275 653 426  |
      | 6    | 【061 087 170 503 512 908】897 275 653 426  |
      | 7    | 【061 087 170 503 512 908】897 275 653 426  |
      | 8    | 【061 087 170 503 512 897 908】275 653 426  |
      | 9    | 【061 087 170 275 503 512 897 908】653 426  |
      | 10   | 【061 087 170 275 503 512 653 897 908】426  |
      | 11   | 【061 087 170 275 426 503 512 653 897 908】 |

   2. 希尔排序

      第一趟：

      ​	子序列：{503,170}{087,897}{512,275}{061,653}{908,426}

      ​	排序：170 087 275 061 426 503 897 512 653 908

      第二趟：

      ​	子序列：{170,061,897,908}{087,426,512}{275,503,653}

      ​	排序：061 087 275 170 426 503 897 512 653 908

      第三趟：

      ​	此时序列基本有序，进行直接插入排序

      ​	排序：061 087 170 275 426 503 512 653 897 908	

   3.  快速排序

      | 趟数            | 关键码状态                                                  |
      | --------------- | ----------------------------------------------------------- |
      | 1【503】        | 426 087 275 061 170 **503** 897 908 653 512                 |
      | 2【426】【897】 | 170 087 275 061 **426** **503** 512 653 **897** 908         |
      | 3【170】【512】 | 061 087 **170** 275 **426** **503** **512** 653 **897** 908 |
      | 4【061】        | 061 087 170 275 426 503 512 653 897 908                     |

   4. 小根堆排序

      初始化堆：

      ![](https://cdn.jsdelivr.net/gh/Easter1995/blog-image/202312191022534.JPG)

      取出061，将908移至堆顶：

      | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
      | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
      | 061  |      |      |      |      |      |      |      |      |      |

      ![](https://cdn.jsdelivr.net/gh/Easter1995/blog-image/202312191101559.JPG)

      取出087，将653移至堆顶：

      | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
      | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
      | 061  | 087  |      |      |      |      |      |      |      |      |

      ![](https://cdn.jsdelivr.net/gh/Easter1995/blog-image/202312191104622.JPG)

      取出170，将908移至堆顶：

      | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
      | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
      | 061  | 087  | 170  |      |      |      |      |      |      |      |

      ![](https://cdn.jsdelivr.net/gh/Easter1995/blog-image/202312191107376.JPG)

      取出275，将897移至堆顶：

      | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
      | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
      | 061  | 087  | 170  | 275  |      |      |      |      |      |      |

      ![](C:\Users\cyh\QQ\1073208733\FileRecv\MobileFile\IMG_4473(20231219-110914).JPG)

      取出426，将653移至堆顶：

      | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
      | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
      | 061  | 087  | 170  | 275  | 426  |      |      |      |      |      |

      ![](https://cdn.jsdelivr.net/gh/Easter1995/blog-image/202312191111222.JPG)

      取出503，将908移至堆顶：

      | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
      | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
      | 061  | 087  | 170  | 275  | 426  | 503  |      |      |      |      |

      ![](https://cdn.jsdelivr.net/gh/Easter1995/blog-image/202312191112652.JPG)

      取出512，将897移至堆顶：

      | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
      | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
      | 061  | 087  | 170  | 275  | 426  | 503  | 512  |      |      |      |

      取出653，将908移至堆顶：

      | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
      | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
      | 061  | 087  | 170  | 275  | 426  | 503  | 512  | 653  |      |      |

      取出897，将908移至堆顶：

      | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
      | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
      | 061  | 087  | 170  | 275  | 426  | 503  | 512  | 653  | 897  |      |

      取出908，排序完成：

      | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
      | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
      | 061  | 087  | 170  | 275  | 426  | 503  | 512  | 653  | 897  | 908  |

   5.  归并排序

      | 趟数 | 关键码状态                              |
      | ---- | --------------------------------------- |
      | 1    | 087 503 061 512 170 908 275 897 426 653 |
      | 2    | 061 087 503 512 170 275 897 908 426 653 |
      | 3    | 061 087 170 275 503 512 897 908 426 653 |
      | 4    | 061 087 170 275 426 503 512 653 897 908 |

   6. 基数排序

      rd=10，d=3

      503 087 512 061 908 170 897 275 653 426

      个位：

      ​	个数：
      
      | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
      | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
      | 1    | 1    | 1    | 2    | 0    | 1    | 1    | 2    | 1    | 0    |
      
      ​	位置：

      | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
      | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
      | 0    | 1    | 2    | 3    | 5    | 5    | 6    | 8    | 9    | 9    |

      ​	最终结果：

      | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
      | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
      | 170  | 061  | 512  | 503  | 653  | 275  | 426  | 087  | 897  | 908  |

      十位：
      
      ​	个数：
      
      | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
      | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
      | 2    | 1    | 1    | 0    | 0    | 1    | 1    | 2    | 1    | 1    |
      
      ​	位置：
      
      | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
      | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
      | 0    | 2    | 3    | 4    | 4    | 4    | 5    | 6    | 8    | 9    |
      
      ​	最终结果：
      
      | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
      | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
      | 503  | 908  | 512  | 426  | 653  | 061  | 170  | 275  | 087  | 897  |
      
      百位：
      
      ​	个数：
      
      | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
      | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
      | 2    | 1    | 1    | 0    | 1    | 2    | 1    | 0    | 1    | 1    |
      
      ​	位置：
      
      | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
      | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
      | 0    | 2    | 3    | 4    | 4    | 5    | 7    | 8    | 8    | 9    |
      
      ​	最终结果：
      
      | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
      | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
      | 061  | 087  | 170  | 275  | 426  | 503  | 512  | 653  | 897  | 908  |

2.   

   1. 败者：在找最小值时，败者是一次PK中较大的叶子节点

   2. 求最大值：b是败者

   3. 败者树的非叶子节点存储的是败者，而堆的父节点是最值。堆的所有节点存储的是有效数据，而败者树非叶子节点存储的是有效数据（叶子节点）PK中产生的败者。

   4.  

      ![](https://cdn.jsdelivr.net/gh/Easter1995/blog-image/202312191136456.JPG)


# 算法题

1. 试以单链表为存储结构实现简单选择排序算法。

   ```c
   typedef struct {
       elemType data;
       elemType* next;
   }NODE,*SqList;
   
   void SelectSort(SqList &L) {
       NODE temp,min;
       for(NODE p = L ; p->next != null ; p = p->next) {
           min = p;
           temp = p;
           for(NODE q = p->next ; q != null ; q = q->next) {
    			if(q->data < min->data) {
                   min = q; //找到q节点之后的最小值
               }           
           }
           while(temp->next != min) temp = temp->next //找到min的前驱
           if(min != p){
               temp->next = min->next;
               min->next = p->next;
               p->next = min; //把min节点移动到p节点之后
           }
       }
       return;
   }
   ```

2. 冒泡排序算法优化，将基本冒泡算法中起控制作用的布尔变量change改成一个整型变量，至少每一趟排序中进行交换的最后一个记录的位置，并以它作为下一趟冒泡排序循环终止的控制值。

   按照现有的逻辑，有序区的长度和排序的轮数是相等的。比如第一轮排序过后的有序区长度是1，第二轮排序过后的有序区长度是2 ......

   实际上，数列真正的有序区可能会大于这个长度，比如例子中仅仅第二轮，后面5个元素实际都已经属于有序区。因此后面的许多次元素比较是没有意义的。

   ```c
   void BubbleSort(SqList &L) {
       int change = n = L.length; //用change记录最后一次交换发生的位置
       int i;
       for (i = 0 ; i < n-1 ; i++) {
           for (j = 0 ; j < change ; j++) {
               if(L.r[j] > L.r[j+1]) {
                   int tmp = L.r[j];
                   L.r[j] = L.r[j+1];
                   L.r[j+1] = tmp;
                   change = j; //记录了最后一次交换的位置，change之后的都是有序列
               }
           }
       }
       return;
   }
   ```
